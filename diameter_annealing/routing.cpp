#include <bits/stdc++.h>
#include <random>
#include <math.h>
#include <numeric>
#include <unordered_set>
#include <unordered_map>
#include <queue>
#include <algorithm> 
#include <chrono> 
#include <map>
#include <iostream> 
using namespace std;
using namespace std::chrono;

#define um unordered_map
#define us unordered_set
//default_random_engine generator;
random_device rd;
mt19937 generator(rd());
uniform_real_distribution<double> uniform_real(0, 1);


/*
TODO:
1. Document all the different attributes and the general logic of every method
2. Add an option to select random paths instead of use the dijkstra
*/



struct Comp
{
  bool operator()(const tuple<int, int, int> &x, const tuple<int, int, int> &y) const
  {
  	if(get<0>(x) == get<0>(y)){
  		return get<1>(x) < get<1>(y);
  	}
    return get<0>(x) > get<0>(y);
  }
};


class BaseRouting {
	/**
	 *
	 * @brief Abstract class used on the simulated annealing class/algorithm to control how to find neighborhood_solution
	 */
	public:
		/**
		 * This is equivalent to calculate the R[node].size() * charge, is only useful to simplify the use of symmetric paths
		 *
		 * @brief Charge of everynode on the routing or how many paths use this node as internal 
		 */
		vector<int> charge_per_node;

		/**
		 * The data structure is equivalent to adjacency list representation but using arrays/vectors
		 * @brief Graph that represent the connection between every pair of nodes
		 */
		vector<vector<int>> g;

		/**
		 * This is equivalent to the sum of the charge of every internal node on the routing
		 *
		 * @brief Charge of every path
		 */
		vector<int> total_charge_per_path;

		/**
		 * This can be implemented in multiple ways
		 * @brief Find a neighborhood solution
		 */
		virtual void neighborhood_solution(){}
		
		/**
		 * It is useful for expensive computations like update the distances using a dijkstra algorithm
		 * @brief Method executed before reduce the temperature on the simulated annealing algorithm
		 */
		virtual void update_routing(){}

		/**
		 * This method is called everytime the simulated annealing algorithm decide to not use the new neighborhood solution
		 *
		 * @brief Method used to forget the new solution. 
		 */
		virtual void forget_neighborhood_solution(){}


		/**
		 *
		 * @brief Return a pair with the forwarding diameter (1) and any other value that is going to break a tie (2)
		 */
		virtual pair<int, int> evaluate(){
			return {0, 0};
		}

};


class SimpleSymmetricRouting: public BaseRouting {
	/**
	 * Implementation of the BaseRounting using symmetric paths and dijkstra to find neighborhood solutions.
	 *
	 * @brief Routing
	 */
	private:
		/**
		 * @brief Ids of all the path, they are generated as autoincrement indexes.
		 */
		unordered_set<int> paths_ids;

		/**
		 * This is useful for speed up the recalculation of the forwarding diameter and is also useful
		 * on the forget_neighborhood_solution method.
		 * @brief Paths added during the execution of the neighborhood_solution method.
		 */
		vector<unordered_set<int>> added_paths;
		/**
		 * This is useful for speed up the recalculation of the forwarding diameter and is also useful
		 * on the forget_neighborhood_solution method.
		 * @brief Paths deleted during the execution of the neighborhood_solution method.
		 */
		vector<unordered_set<int>> erased_paths;

		/**
		 * @brief Vector that contains all the paths that are going to be use to modify the actual routing 
		 */
		vector<int> selected_paths;

		/**
		 * @brief Dijkstra distance of every path
		 */
		vector<int> dijkstra_path_distances;

		/**
		 * Useful only for symmetric paths
		 * @brief Represent the charge generated by every use of a node as a internal path
		 */
		int charge;

		/**
		 * @brief Number of node on the graph
		 */
		int num_nodes;

	public:
		/**
		 * Every cell/node of the vector is a set with all the paths (IDs) that use that node as an internal one.
		 * @brief Routing of the network
		 */
		vector<unordered_set<int>> R;

		
		/**
		 * This attribute is useful to restrict the randomness of the algorithm, an smaller integer (call it N)
		 * means that the algorithm is only going to take into account the top N paths based on the three metrics
		 * described on the neighborhood_solution method, this parameter is combined with the sample_size
		 * 
		 * @brief Determine the number of best possible paths to select randonmly
		 */
		int universe_size;

		/**
		 * Once the numbre of paths is restricted based on the universe_size, they are sorted randomly and then M of them
		 * are selected (this m is the sample_size)
		 * @brief Number of paths that are going to be modified every time the neighborhood_solution method is called
		 */
		int sample_size;

		int 
	
		Routing(){}

		Routing(vector<vector<int>> &g, int sample_size, int universe_size)
		{
			this->g = g;
			this->num_nodes = g.size();
			this->R = vector<unordered_set<int>>(this->num_nodes);
			this->charge_per_node = vector<int>(this->num_nodes);
			this->added_paths = vector<unordered_set<int>>(this->num_nodes, unordered_set<int>());
			this->erased_paths = vector<unordered_set<int>>(this->num_nodes, unordered_set<int>());
			this->total_charge_per_path = vector<int>(this->num_nodes * this->num_nodes, 0);
			this->dijkstra_path_distances = vector<int>(this->num_nodes * this->num_nodes, 0);
			this->charge = 2;
			this->universe_size = universe_size;
			this->sample_size = sample_size;
			this->selected_paths = vector<int>(this->universe_size);

			this->generate_initial_routing();
		}
		Routing(const Routing &a)
		{
			this->num_nodes = a.num_nodes;
			this->R = a.R;
			this->charge_per_node = a.charge_per_node;
			this->g = a.g;
			this->total_charge_per_path = a.total_charge_per_path;
			this->paths_ids = a.paths_ids;
		}
		void generate_initial_routing()
		{
			for(int i = 0; i < this->num_nodes; i++)
				get_random_paths(i);
			
			for(int i = 0; i < this->num_nodes; i++){
				this->charge_per_node[i] = this->R[i].size() * this->charge;
				for(int path: this->R[i]){
					this->total_charge_per_path[path] += this->charge_per_node[i];	
					this->paths_ids.insert(path);
				}
			}
			this->update_routing();
			
		}
		void get_random_paths(int source)
		{
			queue<pair<int, int>> q;
			q.push({source, 0});
			vector<int> distances(this->num_nodes, -1);
			while(!q.empty())
			{
				pair<int, int> temp = q.front();
				int node = temp.first;
				int len = temp.second;
				q.pop();
				if(distances[node] != -1) continue;
				distances[node] = len;
				for(int v: this->g[node])
				{
					if(distances[v] != -1) continue;
					q.push({v, len + 1});
				}
			}
			for(int i = source + 1; i < this->num_nodes; i++)
			{
				int best_distance = distances[i];
				int act_node = i;
				int path_id = source * this->num_nodes + i;
				for(int dist = best_distance; dist > 1; dist--)
				{
					vector<int> valid;
					for(int &node: this->g[act_node])
						if(distances[node] == dist - 1)
							valid.push_back(node);
					uniform_int_distribution<int> uniform_int_path(0, valid.size() - 1);
					int pos = uniform_int_path(generator);
					act_node = valid[pos];
					this->R[act_node].insert(path_id);
				}
			}
		}
		void modify_routing(vector<unordered_set<int>> &new_paths, vector<unordered_set<int>> &old_paths)
		{
			unordered_map<int, int> new_paths_charge, changed_charge_paths;

			for(int i = 0; i < this->num_nodes; i++)
			{
				int new_charge = this->charge * (this->R[i].size() + new_paths[i].size() - old_paths[i].size());
				int change_value = this->charge * (new_paths[i].size() - old_paths[i].size());
				// calculate the new charge for every node based on the amount of new 
				this->charge_per_node[i] = new_charge;

				for(const int &id_path: old_paths[i])
					this->R[i].erase(id_path);

				if(change_value != 0)
					for(int path: this->R[i])
						changed_charge_paths[path] += change_value;
				
				for(const int &id_path: new_paths[i]){
					this->R[i].insert(id_path);
					new_paths_charge[id_path] += new_charge;
				}
			}
			for(const pair<int, int> &path_charge: new_paths_charge)
				this->total_charge_per_path[path_charge.first] = path_charge.second;

			for(const pair<int, int> &path_charge: changed_charge_paths)
				this->total_charge_per_path[path_charge.first] += path_charge.second;
			
		}
		void neighborhood_solution()
		{

			for(int i = 0; i < this->num_nodes; i++)
			{
				this->erased_paths[i].clear();
				this->added_paths[i].clear();
			}

			set<tuple<int, int, int>, Comp> ordered_charge_per_path;
			
			for(int id_path: this->paths_ids)
			{
				int x = id_path / this->num_nodes, y = id_path % this->num_nodes;
				/*
					Every path is sorted based on three elements:
					1. The charge, which is the sum of the charge of the nodes used as internal nodes on the path
					2. The dijkstra distance, explained in the update_routing method
					3. The id of the path, used to break ties


				*/
				ordered_charge_per_path.insert(
					make_tuple(this->total_charge_per_path[id_path], 
					this->dijkstra_path_distances[id_path], 
					id_path
				));

				// preserve only universe_size elements
				if(ordered_charge_per_path.size() > this->universe_size){
					ordered_charge_per_path.erase(prev(ordered_charge_per_path.end()));
				}
			}
			
			// Select and sort randomly the paths on the ordered_charge_per_path 
			int i = 0;
			for(const tuple<int, int, int> &path: ordered_charge_per_path){
				this->selected_paths[i++] = get<2>(path);
			}
			shuffle(this->selected_paths.begin(), this->selected_paths.end(), generator);

			for(int i = 0; i < min(this->sample_size, (int)ordered_charge_per_path.size()); i++)
			{
				int id_path = this->selected_paths[i];

				// remove the previous path first to improve the results of the dijkstra
				for(int j = 0; j < this->num_nodes; j++)
				{
					// verify if the path was using the jth node
					if(this->R[j].find(id_path) == this->R[j].end())
						continue;
					// if it was using the node then reduce the charge of that node (only useful for the dijkstra) 
					// and add it to the erased_paths set
					this->charge_per_node[j] -= this->charge;
					this->erased_paths[j].insert(id_path);
				}

				int x = id_path / this->num_nodes, y = id_path % this->num_nodes;
				// get the dijkstra path from the node X to Y
				vector<int> prev_path_node = this->dijkstra(x, y).second;
				vector<int> path = this->build_path(prev_path_node, x, y);
				for(int v: path)
				{
					// for every node on the path increment the charge (only useful for the dijkstra) 
					// and add it to the added_paths set
					this->charge_per_node[v] += this->charge;
					this->added_paths[v].insert(id_path);
				}	
				
			}
			// modify the routing based on the added and erased paths
			this->modify_routing(this->added_paths, this->erased_paths);

		}
		void update_routing()
		{
			for(int i = 0; i < this->num_nodes; i++){
				vector<int> distances_dijkstra = this->dijkstra(i, -1).first;
				for(int j = 0; j < this->num_nodes; j++)
					this->dijkstra_path_distances[i * this->num_nodes + j] = distances_dijkstra[j];
			}
		}
		void forget_neighborhood_solution()
		{			
			this->modify_routing(this->erased_paths, this->added_paths);
		}
		pair<int, int> evaluate()
		{
			return {
				*max_element(this->total_charge_per_path.begin(), this->total_charge_per_path.end()), 
				*max_element(this->charge_per_node.begin(), this->charge_per_node.end())
			};
		}
		vector<int> build_path(vector<int> &prev, int x, int y)
		{

			vector<int> path;
			int act = y;
			while(prev[act] != act)
			{
				if(prev[act] != x)
					path.push_back(prev[act]);
				act = prev[act];
			}
			reverse(path.begin(), path.end());
			return path;
		}

		pair<vector<int>, vector<int>> dijkstra(int x, int y)
		{
			set<tuple<int,float, int>> q;
			q.insert(make_tuple(0, uniform_real(generator), x));
			vector<int> dist_per_node(this->num_nodes, INT_MAX);
			vector<int> prev(this->num_nodes);
			prev[x] = x;
			dist_per_node[x] = 0;
			while(not q.empty())
			{
				tuple<int, int, int> temp = *q.begin();
				int dist = get<0>(temp), random_value = get<1>(temp), node = get<2>(temp);
				if(dist < 0)
					break;
				dist_per_node[node] = dist;
				q.erase(q.begin());
				if(node == y) 
					break;

				for(int &adj: this->g[node])
				{
					if(dist_per_node[adj] > dist + this->charge_per_node[adj] + 2)
					{
						prev[adj] = node;
						q.erase(make_tuple(dist_per_node[adj], random_value, adj));
						dist_per_node[adj] = dist + this->charge_per_node[adj] + 2;
						q.insert(make_tuple(dist_per_node[adj], uniform_real(generator), adj));
					}
				}
			}
			return {dist_per_node, prev};
		}
};